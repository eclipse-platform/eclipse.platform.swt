package org.eclipse.swt.examples.fileviewer;/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved */import org.eclipse.swt.*;import org.eclipse.swt.dnd.*;import org.eclipse.swt.graphics.*;import org.eclipse.swt.widgets.*;/** * TreeDropFeedbackListener provides the following feedback mechanisms for Trees * during drag and drop operations: * <ul> * <li>Automatic Tree scrolling. *     <p>If the pointer drags over an item in the Tree near its upper or *     lower edges, the Tree will scroll so as to make previous or successive items visible *     onscreen.  This behaviour is consistent with that of popular GUI systems. *     </p> * <li>Automatic TreeItem expansion. *     <p>If the pointer hovers for a time over an item in the Tree that has not yet been *     expanded, the item is expanded automatically.  This behaviour is consistent with *     that of popular GUI systems. *     </p> * </ul> * <p> * To use it send addDropListener(new TreeDropFeedbackListener(tree)) to the DropTarget * object attached to the Tree. * </p> */public class TreeDropFeedbackListener extends DropTargetAdapter {	protected static final int EXPAND_DELAY = 750; // millis	protected static final int SCROLL_DELAY = 50; // millis	protected static final int MAX_SCROLL_TRIES = 3; 	protected Tree     tree;	protected TreeItem hoverItem = null;	protected Point    hoverPoint = null;	protected Runnable hoverRunnable = null;	protected long     hoverResumeTime = 0;	/**	 * Constructs a Tree scrolling Drop Listener	 * 	 * @param tree the Tree that the DropTarget is attached to	 */	public TreeDropFeedbackListener(Tree tree) {		this.tree = tree;	}	/**	 * Handles dragEnter events.	 */	public void dragEnter(DropTargetEvent event) {		hoverItem = null;		hoverRunnable = null;	}	/**	 * Handles dragExit events.	 */	public void dragExit(DropTargetEvent event) {		hoverItem = null;		hoverRunnable = null;	}	/**	 * Handles dragOver events.	 * <p>	 * On Windows, we receive multiple dragOver()'s even if the mouse has not moved.	 * But we can't get timerExec()'s.<br>	 * <br>	 * On Motif, we only get dragOver()'s when the mouse has actually moved.	 * But timerExec()'s are processed as usual.<br>	 * <br>	 * So to ensure cross-platform UI consistency we must handle both cases!	 * </p>	 */	public void dragOver(DropTargetEvent event) {		Point point = tree.toControl(new Point(event.x, event.y));		// Fetch the item we're hovering over		TreeItem item = tree.getItem(point);		if ((hoverRunnable != null) && (item == hoverItem)) {			if (System.currentTimeMillis() >= hoverResumeTime) hoverRunnable.run();			return;		}		hoverItem = item;		hoverPoint = point;		/*		 * Determine the candidate action for this position: nothing, scroll or expand		 */		hoverRunnable = null;		if (hoverItem == null) return; // Nothing to do		// Consider scrolling		Rectangle clientArea = tree.getClientArea();		int scrollRegionSize = Math.min(clientArea.height / 3, 24); // cut region into 3 parts		if (scrollRegionSize >= 8) {			// Decide scroll direction according to whether we're nearer the top, middle, or bottom			if (point.y < clientArea.y + scrollRegionSize) {				// in upper region				setTimer(SCROLL_DELAY, new ScrollRunnable(true));				return;			} else if (point.y > clientArea.height + clientArea.y - scrollRegionSize) {				// in lower region				setTimer(SCROLL_DELAY, new ScrollRunnable(false));				return;			}			// else we are in middle region		}		// else the region is too small for scrolling		tryExpand(0);	}	private void tryExpand(int recoverTime) {		// Expand the item if it hasn't already been expanded		if (! hoverItem.getExpanded()) {			setTimer(EXPAND_DELAY - recoverTime, new ExpandRunnable());		}	}	private void setTimer(int delay, Runnable runnable) {		hoverRunnable = runnable;		hoverResumeTime = System.currentTimeMillis() + delay;		tree.getDisplay().timerExec(delay, hoverRunnable);	}	/**	 * Implements scrolling on a timer	 */	private class ScrollRunnable implements Runnable {		boolean isScrollUp;		public ScrollRunnable(boolean isScrollUp) {			this.isScrollUp = isScrollUp;		}		public void run() {			if (hoverRunnable != this) return;			hoverRunnable = null;			if (hoverItem.isDisposed()) return; // this can happen due to other events			System.out.println("Scroll");			// Loop until we see a different item (abort after a few tries, just in case)			TreeItem showItem = hoverItem;			for (int i = MAX_SCROLL_TRIES; i > 0; --i) {				showItem = (isScrollUp) ? getPreviousVisibleItem(tree, showItem) :					getNextVisibleItem(tree, showItem, false);								// Show the item (causes a scroll if it is outside of the visible region)				if (showItem == null) break;				tree.showItem(showItem);								if (hoverItem != tree.getItem(hoverPoint)) return; // stop if we actually scrolled			}						// We get here if we failed to scroll			tryExpand(SCROLL_DELAY); // try auto-expand if auto-scroll failed		}	}					/**	 * Implements expanding on a timer	 */	private class ExpandRunnable implements Runnable {		public void run() {			if (hoverRunnable != this) return;			hoverRunnable = null;			if (hoverItem.isDisposed()) return; // this can happen due to other events			System.out.println("Expand");			// Fake as if the user expanded the item manually			Event hoverEvent = new Event();			hoverEvent.x = hoverPoint.x;			hoverEvent.y = hoverPoint.y;			hoverEvent.item = hoverItem;			hoverEvent.time = (int) System.currentTimeMillis();			hoverItem.setExpanded(true);			tree.notifyListeners(SWT.Expand, hoverEvent);		}	}				/**	 * Given a TreeItem, locates the previous (above the specified item) visible TreeItem in a tree.	 * <p>	 * Note that the item may not be actually rendered onscreen though it would be	 * visible were the control scrolled appropriately.	 * </p>	 * 	 * @param tree the Tree containing the items	 * @param item the TreeItem whose previous visible neighbour is to be found	 * @return the previous visible item, or null if none.	 */	private TreeItem getPreviousVisibleItem(Tree tree, TreeItem item) {		TreeItem parent = item.getParentItem();		TreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();		if (items != null) {			for (int i = items.length - 1; i > 0; --i) {				if (items[i] == item) return getLastVisibleChild(items[i - 1]);			}		}		return parent;	}	/**	 * Given a TreeItem, locates the following (below the specified item) visible TreeItem in a tree.	 * <p>	 * Note that the item may not be actually rendered onscreen though it would be	 * visible were the control scrolled appropriately.	 * </p>	 * 	 * @param tree the Tree containing the items	 * @param item the TreeItem whose next visible neighbour is to be found	 * @return the next visible item, or null if none.	 */	private TreeItem getNextVisibleItem(Tree tree, TreeItem item, boolean ignoreChildren) {		TreeItem parent = item.getParentItem();		TreeItem[] items = (parent != null) ? parent.getItems() : tree.getItems();		if (items != null) {			for (int i = 0; i < items.length; ++i) {				if (items[i] == item) {					if (! ignoreChildren && items[i].getExpanded()) {						items = items[i].getItems();						if (items != null && items.length > 0) return items[0];					}					if (i + 1 < items.length) return items[i + 1];					break;				}			}			if (parent != null) return getNextVisibleItem(tree, parent, true);		}		return null;	}	/**	 * Given a TreeItem, locates its last (lowest) visible item	 * <p>	 * Note that the item may not be actually rendered onscreen though it would be	 * visible were the control scrolled appropriately.	 * </p>	 * 	 * @param item the TreeItem whose last visible child is to be found	 * @return the last visible child, or <code>item</code> if no visible children.	 */	private TreeItem getLastVisibleChild(TreeItem item) {		if (! item.getExpanded()) return item;				TreeItem[] items = item.getItems();		if (items == null || items.length == 0) return item;		return getLastVisibleChild(items[items.length - 1]);	}}